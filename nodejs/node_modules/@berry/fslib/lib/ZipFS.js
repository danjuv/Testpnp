"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const libzip_1 = __importDefault(require("@berry/libzip"));
const fs_1 = require("fs");
const stream_1 = require("stream");
const util_1 = require("util");
const FakeFS_1 = require("./FakeFS");
const NodeFS_1 = require("./NodeFS");
const path_1 = require("./path");
const S_IFMT = 0o170000;
const S_IFDIR = 0o040000;
const S_IFREG = 0o100000;
const S_IFLNK = 0o120000;
class StatEntry {
    constructor() {
        this.dev = 0;
        this.ino = 0;
        this.mode = 0;
        this.nlink = 1;
        this.rdev = 0;
        this.blocks = 1;
    }
    isBlockDevice() {
        return false;
    }
    isCharacterDevice() {
        return false;
    }
    isDirectory() {
        return (this.mode & S_IFMT) === S_IFDIR;
    }
    isFIFO() {
        return false;
    }
    isFile() {
        return (this.mode & S_IFMT) === S_IFREG;
    }
    isSocket() {
        return false;
    }
    isSymbolicLink() {
        return (this.mode & S_IFMT) === S_IFLNK;
    }
}
function makeDefaultStats() {
    return Object.assign(new StatEntry(), {
        uid: 0,
        gid: 0,
        size: 0,
        blksize: 0,
        atimeMs: 0,
        mtimeMs: 0,
        ctimeMs: 0,
        birthtimeMs: 0,
        atime: new Date(0),
        mtime: new Date(0),
        ctime: new Date(0),
        birthtime: new Date(0),
        mode: S_IFREG | 0o644,
    });
}
function toUnixTimestamp(time) {
    if (typeof time === 'string' && String(+time) === time)
        return +time;
    // @ts-ignore
    if (Number.isFinite(time)) {
        if (time < 0) {
            return Date.now() / 1000;
        }
        else {
            return time;
        }
    }
    // convert to 123.456 UNIX timestamp
    if (util_1.isDate(time))
        return time.getTime() / 1000;
    throw new Error(`Invalid time`);
}
class ZipFS extends FakeFS_1.BasePortableFakeFS {
    constructor(source, opts) {
        super();
        this.listings = new Map();
        this.entries = new Map();
        this.ready = false;
        const pathOptions = opts;
        if (typeof source === `string`) {
            const { baseFs = new NodeFS_1.NodeFS() } = pathOptions;
            this.baseFs = baseFs;
            this.path = source;
        }
        else {
            this.path = null;
            this.baseFs = null;
        }
        if (opts.stats) {
            this.stats = opts.stats;
        }
        else {
            if (typeof source === `string`) {
                try {
                    this.stats = this.baseFs.statSync(source);
                }
                catch (error) {
                    if (error.code === `ENOENT` && pathOptions.create) {
                        this.stats = makeDefaultStats();
                    }
                    else {
                        throw error;
                    }
                }
            }
            else {
                this.stats = makeDefaultStats();
            }
        }
        const errPtr = libzip_1.default.malloc(4);
        try {
            let flags = 0;
            if (typeof source === `string` && pathOptions.create)
                flags |= libzip_1.default.ZIP_CREATE | libzip_1.default.ZIP_TRUNCATE;
            if (opts.readOnly)
                flags |= libzip_1.default.ZIP_RDONLY;
            if (typeof source === `string`) {
                this.zip = libzip_1.default.open(NodeFS_1.NodeFS.fromPortablePath(source), flags, errPtr);
            }
            else {
                const lzSource = this.allocateUnattachedSource(source);
                try {
                    this.zip = libzip_1.default.openFromSource(lzSource, flags, errPtr);
                }
                catch (error) {
                    libzip_1.default.source.free(lzSource);
                    throw error;
                }
            }
            if (this.zip === 0) {
                const error = libzip_1.default.struct.errorS();
                libzip_1.default.error.initWithCode(error, libzip_1.default.getValue(errPtr, `i32`));
                throw new Error(libzip_1.default.error.strerror(error));
            }
        }
        finally {
            libzip_1.default.free(errPtr);
        }
        this.listings.set(path_1.PortablePath.root, new Set());
        const entryCount = libzip_1.default.getNumEntries(this.zip, 0);
        for (let t = 0; t < entryCount; ++t) {
            const raw = libzip_1.default.getName(this.zip, t, 0);
            if (path_1.ppath.isAbsolute(raw))
                continue;
            const p = path_1.ppath.resolve(path_1.PortablePath.root, raw);
            this.registerEntry(p, t);
            // If the raw path is a directory, register it
            // to prevent empty folder being skipped
            if (raw.endsWith('/')) {
                this.registerListing(p);
            }
        }
        this.ready = true;
    }
    getAllFiles() {
        return Array.from(this.entries.keys());
    }
    getRealPath() {
        if (!this.path)
            throw new Error(`ZipFS don't have real paths when loaded from a buffer`);
        return this.path;
    }
    saveAndClose() {
        if (!this.path || !this.baseFs)
            throw new Error(`ZipFS cannot be saved and must be discarded when loaded from a buffer`);
        if (!this.ready)
            throw Object.assign(new Error(`EBUSY: archive closed, close`), { code: `EBUSY` });
        const previousMod = this.baseFs.existsSync(this.path)
            ? this.baseFs.statSync(this.path).mode & 0o777
            : null;
        const rc = libzip_1.default.close(this.zip);
        if (rc === -1)
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        // Libzip overrides the chmod when writing the archive, which is a weird
        // behavior I don't totally understand (plus the umask seems bogus in some
        // weird cases - maybe related to emscripten?)
        //
        // See also https://github.com/nih-at/libzip/issues/77
        if (previousMod !== null && previousMod !== (this.baseFs.statSync(this.path).mode & 0o777))
            this.baseFs.chmodSync(this.path, previousMod);
        this.ready = false;
    }
    discardAndClose() {
        libzip_1.default.discard(this.zip);
        this.ready = false;
    }
    async openPromise(p, flags, mode) {
        return this.openSync(p, flags, mode);
    }
    openSync(p, flags, mode) {
        throw new Error(`Unimplemented`);
    }
    async closePromise(fd) {
        this.closeSync(fd);
    }
    closeSync(fd) {
        throw new Error(`Unimplemented`);
    }
    createReadStream(p, { encoding } = {}) {
        if (p === null)
            throw new Error(`Unimplemented`);
        const stream = Object.assign(new stream_1.PassThrough(), {
            bytesRead: 0,
            path: p,
            close: () => {
                clearImmediate(immediate);
            },
        });
        const immediate = setImmediate(() => {
            try {
                const data = this.readFileSync(p, encoding);
                stream.bytesRead = data.length;
                stream.write(data);
                stream.end();
            }
            catch (error) {
                stream.emit(`error`, error);
                stream.end();
            }
        });
        return stream;
    }
    createWriteStream(p, { encoding } = {}) {
        if (p === null)
            throw new Error(`Unimplemented`);
        const stream = Object.assign(new stream_1.PassThrough(), {
            bytesWritten: 0,
            path: p,
            close: () => {
                stream.end();
            },
        });
        const chunks = [];
        stream.on(`data`, chunk => {
            const chunkBuffer = Buffer.from(chunk);
            stream.bytesWritten += chunkBuffer.length;
            chunks.push(chunkBuffer);
        });
        stream.on(`end`, () => {
            this.writeFileSync(p, Buffer.concat(chunks), encoding);
        });
        return stream;
    }
    async realpathPromise(p) {
        return this.realpathSync(p);
    }
    realpathSync(p) {
        const resolvedP = this.resolveFilename(`lstat '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOENT: no such file or directory, lstat '${p}'`), { code: `ENOENT` });
        return resolvedP;
    }
    async existsPromise(p) {
        return this.existsSync(p);
    }
    existsSync(p) {
        let resolvedP;
        try {
            resolvedP = this.resolveFilename(`stat '${p}'`, p);
        }
        catch (error) {
            return false;
        }
        return this.entries.has(resolvedP) || this.listings.has(resolvedP);
    }
    async accessPromise(p, mode) {
        return this.accessSync(p, mode);
    }
    accessSync(p, mode) {
        const resolvedP = this.resolveFilename(`access '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) {
            throw Object.assign(new Error(`ENOENT: no such file or directory, access '${p}'`), { code: `ENOENT` });
        }
    }
    async statPromise(p) {
        return this.statSync(p);
    }
    statSync(p) {
        const resolvedP = this.resolveFilename(`stat '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOENT: no such file or directory, stat '${p}'`), { code: `ENOENT` });
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOTDIR: not a directory, stat '${p}'`), { code: `ENOTDIR` });
        return this.statImpl(`stat '${p}'`, resolvedP);
    }
    async lstatPromise(p) {
        return this.lstatSync(p);
    }
    lstatSync(p) {
        const resolvedP = this.resolveFilename(`lstat '${p}'`, p, false);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOENT: no such file or directory, lstat '${p}'`), { code: `ENOENT` });
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOTDIR: not a directory, lstat '${p}'`), { code: `ENOTDIR` });
        return this.statImpl(`lstat '${p}'`, resolvedP);
    }
    statImpl(reason, p) {
        if (this.listings.has(p)) {
            const uid = this.stats.uid;
            const gid = this.stats.gid;
            const size = 0;
            const blksize = 512;
            const blocks = 0;
            const atimeMs = this.stats.mtimeMs;
            const birthtimeMs = this.stats.mtimeMs;
            const ctimeMs = this.stats.mtimeMs;
            const mtimeMs = this.stats.mtimeMs;
            const atime = new Date(atimeMs);
            const birthtime = new Date(birthtimeMs);
            const ctime = new Date(ctimeMs);
            const mtime = new Date(mtimeMs);
            const mode = S_IFDIR | 0o755;
            return Object.assign(new StatEntry(), { uid, gid, size, blksize, blocks, atime, birthtime, ctime, mtime, atimeMs, birthtimeMs, ctimeMs, mtimeMs, mode });
        }
        const entry = this.entries.get(p);
        if (entry !== undefined) {
            const stat = libzip_1.default.struct.statS();
            const rc = libzip_1.default.statIndex(this.zip, entry, 0, 0, stat);
            if (rc === -1)
                throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
            const uid = this.stats.uid;
            const gid = this.stats.gid;
            const size = (libzip_1.default.struct.statSize(stat) >>> 0);
            const blksize = 512;
            const blocks = Math.ceil(size / blksize);
            const mtimeMs = (libzip_1.default.struct.statMtime(stat) >>> 0) * 1000;
            const atimeMs = mtimeMs;
            const birthtimeMs = mtimeMs;
            const ctimeMs = mtimeMs;
            const atime = new Date(atimeMs);
            const birthtime = new Date(birthtimeMs);
            const ctime = new Date(ctimeMs);
            const mtime = new Date(mtimeMs);
            const mode = this.getUnixMode(entry, S_IFREG | 0o644);
            return Object.assign(new StatEntry(), { uid, gid, size, blksize, blocks, atime, birthtime, ctime, mtime, atimeMs, birthtimeMs, ctimeMs, mtimeMs, mode });
        }
        throw new Error(`Unreachable`);
    }
    getUnixMode(index, defaultMode) {
        const rc = libzip_1.default.file.getExternalAttributes(this.zip, index, 0, 0, libzip_1.default.uint08S, libzip_1.default.uint32S);
        if (rc === -1)
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        const opsys = libzip_1.default.getValue(libzip_1.default.uint08S, `i8`) >>> 0;
        if (opsys !== libzip_1.default.ZIP_OPSYS_UNIX)
            return defaultMode;
        return libzip_1.default.getValue(libzip_1.default.uint32S, `i32`) >>> 16;
    }
    registerListing(p) {
        let listing = this.listings.get(p);
        if (listing)
            return listing;
        const parentListing = this.registerListing(path_1.ppath.dirname(p));
        listing = new Set();
        parentListing.add(path_1.ppath.basename(p));
        this.listings.set(p, listing);
        return listing;
    }
    registerEntry(p, index) {
        const parentListing = this.registerListing(path_1.ppath.dirname(p));
        parentListing.add(path_1.ppath.basename(p));
        this.entries.set(p, index);
    }
    resolveFilename(reason, p, resolveLastComponent = true) {
        if (!this.ready)
            throw Object.assign(new Error(`EBUSY: archive closed, ${reason}`), { code: `EBUSY` });
        let resolvedP = path_1.ppath.resolve(path_1.PortablePath.root, p);
        if (resolvedP === `/`)
            return path_1.PortablePath.root;
        while (true) {
            const parentP = this.resolveFilename(reason, path_1.ppath.dirname(resolvedP), true);
            const isDir = this.listings.has(parentP);
            const doesExist = this.entries.has(parentP);
            if (!isDir && !doesExist)
                throw Object.assign(new Error(`ENOENT: no such file or directory, ${reason}`), { code: `ENOENT` });
            if (!isDir)
                throw Object.assign(new Error(`ENOTDIR: not a directory, ${reason}`), { code: `ENOTDIR` });
            resolvedP = path_1.ppath.resolve(parentP, path_1.ppath.basename(resolvedP));
            if (!resolveLastComponent)
                break;
            const index = libzip_1.default.name.locate(this.zip, resolvedP);
            if (index === -1)
                break;
            if (this.isSymbolicLink(index)) {
                const target = this.getFileSource(index).toString();
                resolvedP = path_1.ppath.resolve(path_1.ppath.dirname(resolvedP), target);
            }
            else {
                break;
            }
        }
        return resolvedP;
    }
    allocateBuffer(content) {
        if (!Buffer.isBuffer(content))
            content = Buffer.from(content);
        const buffer = libzip_1.default.malloc(content.byteLength);
        if (!buffer)
            throw new Error(`Couldn't allocate enough memory`);
        // Copy the file into the Emscripten heap
        const heap = new Uint8Array(libzip_1.default.HEAPU8.buffer, buffer, content.byteLength);
        heap.set(content);
        return { buffer, byteLength: content.byteLength };
    }
    allocateUnattachedSource(content) {
        const error = libzip_1.default.struct.errorS();
        const { buffer, byteLength } = this.allocateBuffer(content);
        const source = libzip_1.default.source.fromUnattachedBuffer(buffer, byteLength, 0, true, error);
        if (source === 0) {
            libzip_1.default.free(error);
            throw new Error(libzip_1.default.error.strerror(error));
        }
        return source;
    }
    allocateSource(content) {
        const { buffer, byteLength } = this.allocateBuffer(content);
        const source = libzip_1.default.source.fromBuffer(this.zip, buffer, byteLength, 0, true);
        if (source === 0) {
            libzip_1.default.free(buffer);
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        }
        return source;
    }
    setFileSource(p, content) {
        const target = path_1.ppath.relative(path_1.PortablePath.root, p);
        const lzSource = this.allocateSource(content);
        try {
            return libzip_1.default.file.add(this.zip, target, lzSource, libzip_1.default.ZIP_FL_OVERWRITE);
        }
        catch (error) {
            libzip_1.default.source.free(lzSource);
            throw error;
        }
    }
    isSymbolicLink(index) {
        const attrs = libzip_1.default.file.getExternalAttributes(this.zip, index, 0, 0, libzip_1.default.uint08S, libzip_1.default.uint32S);
        if (attrs === -1)
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        const opsys = libzip_1.default.getValue(libzip_1.default.uint08S, `i8`) >>> 0;
        if (opsys !== libzip_1.default.ZIP_OPSYS_UNIX)
            return false;
        const attributes = libzip_1.default.getValue(libzip_1.default.uint32S, `i32`) >>> 16;
        return (attributes & S_IFMT) === S_IFLNK;
    }
    getFileSource(index) {
        const stat = libzip_1.default.struct.statS();
        const rc = libzip_1.default.statIndex(this.zip, index, 0, 0, stat);
        if (rc === -1)
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        const size = libzip_1.default.struct.statSize(stat);
        const buffer = libzip_1.default.malloc(size);
        try {
            const file = libzip_1.default.fopenIndex(this.zip, index, 0, 0);
            if (file === 0)
                throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
            try {
                const rc = libzip_1.default.fread(file, buffer, size, 0);
                if (rc === -1)
                    throw new Error(libzip_1.default.error.strerror(libzip_1.default.file.getError(file)));
                else if (rc < size)
                    throw new Error(`Incomplete read`);
                else if (rc > size)
                    throw new Error(`Overread`);
                const memory = libzip_1.default.HEAPU8.subarray(buffer, buffer + size);
                const data = Buffer.from(memory);
                return data;
            }
            finally {
                libzip_1.default.fclose(file);
            }
        }
        finally {
            libzip_1.default.free(buffer);
        }
    }
    async chmodPromise(p, mask) {
        return this.chmodSync(p, mask);
    }
    chmodSync(p, mask) {
        const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
        // We silently ignore chmod requests for directories
        if (this.listings.has(resolvedP))
            return;
        const entry = this.entries.get(resolvedP);
        if (entry === undefined)
            throw new Error(`Unreachable`);
        const oldMod = this.getUnixMode(entry, S_IFREG | 0o000);
        const newMod = oldMod & (~0o777) | mask;
        const rc = libzip_1.default.file.setExternalAttributes(this.zip, entry, 0, 0, libzip_1.default.ZIP_OPSYS_UNIX, newMod << 16);
        if (rc === -1) {
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        }
    }
    async renamePromise(oldP, newP) {
        return this.renameSync(oldP, newP);
    }
    renameSync(oldP, newP) {
        throw new Error(`Unimplemented`);
    }
    async copyFilePromise(sourceP, destP, flags) {
        return this.copyFileSync(sourceP, destP, flags);
    }
    copyFileSync(sourceP, destP, flags = 0) {
        if ((flags & fs_1.constants.COPYFILE_FICLONE_FORCE) !== 0)
            throw Object.assign(new Error(`ENOSYS: unsupported clone operation, copyfile '${sourceP}' -> ${destP}'`), { code: `ENOSYS` });
        const resolvedSourceP = this.resolveFilename(`copyfile '${sourceP} -> ${destP}'`, sourceP);
        const indexSource = this.entries.get(resolvedSourceP);
        if (typeof indexSource === `undefined`)
            throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), { code: `EINVAL` });
        const resolvedDestP = this.resolveFilename(`copyfile '${sourceP}' -> ${destP}'`, destP);
        const indexDest = this.entries.get(resolvedDestP);
        if ((flags & (fs_1.constants.COPYFILE_EXCL | fs_1.constants.COPYFILE_FICLONE_FORCE)) !== 0 && typeof indexDest !== `undefined`)
            throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), { code: `EEXIST` });
        const source = this.getFileSource(indexSource);
        const newIndex = this.setFileSource(resolvedDestP, source);
        if (newIndex !== indexDest) {
            this.registerEntry(resolvedDestP, newIndex);
        }
    }
    async writeFilePromise(p, content, opts) {
        return this.writeFileSync(p, content, opts);
    }
    writeFileSync(p, content, opts) {
        const resolvedP = this.resolveFilename(`open '${p}'`, p);
        if (this.listings.has(resolvedP))
            throw Object.assign(new Error(`EISDIR: illegal operation on a directory, open '${p}'`), { code: `EISDIR` });
        const index = this.entries.get(resolvedP);
        if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`))
            content = Buffer.concat([this.getFileSource(index), Buffer.from(content)]);
        let encoding = null;
        if (typeof opts === `string`)
            encoding = opts;
        else if (typeof opts === `object` && opts.encoding)
            encoding = opts.encoding;
        if (encoding !== null)
            content = content.toString(encoding);
        const newIndex = this.setFileSource(resolvedP, content);
        if (newIndex !== index) {
            this.registerEntry(resolvedP, newIndex);
        }
    }
    async unlinkPromise(p) {
        return this.unlinkSync(p);
    }
    unlinkSync(p) {
        throw new Error(`Unimplemented`);
    }
    async utimesPromise(p, atime, mtime) {
        return this.utimesSync(p, atime, mtime);
    }
    utimesSync(p, atime, mtime) {
        const resolvedP = this.resolveFilename(`chmod '${p}'`, p);
        return this.utimesImpl(resolvedP, mtime);
    }
    async lutimesPromise(p, atime, mtime) {
        return this.lutimesSync(p, atime, mtime);
    }
    lutimesSync(p, atime, mtime) {
        const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
        return this.utimesImpl(resolvedP, mtime);
    }
    utimesImpl(resolvedP, mtime) {
        if (this.listings.has(resolvedP))
            if (!this.entries.has(resolvedP))
                this.hydrateDirectory(resolvedP);
        const entry = this.entries.get(resolvedP);
        if (entry === undefined)
            throw new Error(`Unreachable`);
        const rc = libzip_1.default.file.setMtime(this.zip, entry, 0, toUnixTimestamp(mtime), 0);
        if (rc === -1) {
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        }
    }
    async mkdirPromise(p) {
        return this.mkdirSync(p);
    }
    mkdirSync(p) {
        const resolvedP = this.resolveFilename(`mkdir '${p}'`, p);
        if (this.entries.has(resolvedP) || this.listings.has(resolvedP))
            throw Object.assign(new Error(`EEXIST: file already exists, mkdir '${p}'`), { code: `EEXIST` });
        this.hydrateDirectory(resolvedP);
    }
    async rmdirPromise(p) {
        return this.rmdirSync(p);
    }
    rmdirSync(p) {
        throw new Error(`Unimplemented`);
    }
    hydrateDirectory(resolvedP) {
        const index = libzip_1.default.dir.add(this.zip, path_1.ppath.relative(path_1.PortablePath.root, resolvedP));
        if (index === -1)
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        this.registerListing(resolvedP);
        this.registerEntry(resolvedP, index);
        return index;
    }
    async symlinkPromise(target, p) {
        return this.symlinkSync(target, p);
    }
    symlinkSync(target, p) {
        const resolvedP = this.resolveFilename(`symlink '${target}' -> '${p}'`, p);
        if (this.listings.has(resolvedP))
            throw Object.assign(new Error(`EISDIR: illegal operation on a directory, symlink '${target}' -> '${p}'`), { code: `EISDIR` });
        if (this.entries.has(resolvedP))
            throw Object.assign(new Error(`EEXIST: file already exists, symlink '${target}' -> '${p}'`), { code: `EEXIST` });
        const index = this.setFileSource(resolvedP, target);
        this.registerEntry(resolvedP, index);
        const rc = libzip_1.default.file.setExternalAttributes(this.zip, index, 0, 0, libzip_1.default.ZIP_OPSYS_UNIX, (0o120000 | 0o777) << 16);
        if (rc === -1) {
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        }
    }
    async readFilePromise(p, encoding) {
        // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
        switch (encoding) {
            case `utf8`:
                return this.readFileSync(p, encoding);
            default:
                return this.readFileSync(p, encoding);
        }
    }
    readFileSync(p, encoding) {
        // This is messed up regarding the TS signatures
        if (typeof encoding === `object`)
            // @ts-ignore
            encoding = encoding ? encoding.encoding : undefined;
        const resolvedP = this.resolveFilename(`open '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOENT: no such file or directory, open '${p}'`), { code: `ENOENT` });
        // Ensures that the last component is a directory, if the user said so (even if it is we'll throw right after with EISDIR anyway)
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOTDIR: not a directory, open '${p}'`), { code: `ENOTDIR` });
        if (this.listings.has(resolvedP))
            throw Object.assign(new Error(`EISDIR: illegal operation on a directory, read`), { code: `EISDIR` });
        const entry = this.entries.get(resolvedP);
        if (entry === undefined)
            throw new Error(`Unreachable`);
        const data = this.getFileSource(entry);
        return encoding ? data.toString(encoding) : data;
    }
    async readdirPromise(p) {
        return this.readdirSync(p);
    }
    readdirSync(p) {
        const resolvedP = this.resolveFilename(`scandir '${p}'`, p);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOENT: no such file or directory, scandir '${p}'`), { code: `ENOENT` });
        const directoryListing = this.listings.get(resolvedP);
        if (!directoryListing)
            throw Object.assign(new Error(`ENOTDIR: not a directory, scandir '${p}'`), { code: `ENOTDIR` });
        return Array.from(directoryListing);
    }
    async readlinkPromise(p) {
        return this.readlinkSync(p);
    }
    readlinkSync(p) {
        const resolvedP = this.resolveFilename(`readlink '${p}'`, p, false);
        if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOENT: no such file or directory, readlink '${p}'`), { code: `ENOENT` });
        // Ensure that the last component is a directory (if it is we'll throw right after with EISDIR anyway)
        if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
            throw Object.assign(new Error(`ENOTDIR: not a directory, open '${p}'`), { code: `ENOTDIR` });
        if (this.listings.has(resolvedP))
            throw Object.assign(new Error(`EINVAL: invalid argument, readlink '${p}'`), { code: `EINVAL` });
        const entry = this.entries.get(resolvedP);
        if (entry === undefined)
            throw new Error(`Unreachable`);
        const rc = libzip_1.default.file.getExternalAttributes(this.zip, entry, 0, 0, libzip_1.default.uint08S, libzip_1.default.uint32S);
        if (rc === -1)
            throw new Error(libzip_1.default.error.strerror(libzip_1.default.getError(this.zip)));
        const opsys = libzip_1.default.getValue(libzip_1.default.uint08S, `i8`) >>> 0;
        if (opsys !== libzip_1.default.ZIP_OPSYS_UNIX)
            throw Object.assign(new Error(`EINVAL: invalid argument, readlink '${p}'`), { code: `EINVAL` });
        const attributes = libzip_1.default.getValue(libzip_1.default.uint32S, `i32`) >>> 16;
        if ((attributes & 0o170000) !== 0o120000)
            throw Object.assign(new Error(`EINVAL: invalid argument, readlink '${p}'`), { code: `EINVAL` });
        return this.getFileSource(entry).toString();
    }
}
exports.ZipFS = ZipFS;
;
