/// <reference types="node" />
import { CreateReadStreamOptions, CreateWriteStreamOptions, FakeFS } from './FakeFS';
import { WriteFileOptions } from './FakeFS';
import { Path } from './path';
export declare abstract class ProxiedFS<P extends Path, IP extends Path> extends FakeFS<P> {
    protected abstract readonly baseFs: FakeFS<IP>;
    /**
     * Convert a path from the user format into what should be fed into the internal FS.
     */
    protected abstract mapToBase(path: P): IP;
    /**
     * Convert a path from the format supported by the base FS into the user one.
     */
    protected abstract mapFromBase(path: IP): P;
    resolve(path: P): P;
    getRealPath(): P;
    openPromise(p: P, flags: string, mode?: number): Promise<number>;
    openSync(p: P, flags: string, mode?: number): number;
    closePromise(fd: number): void;
    closeSync(fd: number): void;
    createReadStream(p: P | null, opts?: CreateReadStreamOptions): import("fs").ReadStream;
    createWriteStream(p: P | null, opts?: CreateWriteStreamOptions): import("fs").WriteStream;
    realpathPromise(p: P): Promise<P>;
    realpathSync(p: P): P;
    existsPromise(p: P): Promise<boolean>;
    existsSync(p: P): boolean;
    accessSync(p: P, mode?: number): void;
    accessPromise(p: P, mode?: number): Promise<void>;
    statPromise(p: P): Promise<import("fs").Stats>;
    statSync(p: P): import("fs").Stats;
    lstatPromise(p: P): Promise<import("fs").Stats>;
    lstatSync(p: P): import("fs").Stats;
    chmodPromise(p: P, mask: number): Promise<void>;
    chmodSync(p: P, mask: number): void;
    renamePromise(oldP: P, newP: P): Promise<void>;
    renameSync(oldP: P, newP: P): void;
    copyFilePromise(sourceP: P, destP: P, flags?: number): Promise<void>;
    copyFileSync(sourceP: P, destP: P, flags?: number): void;
    writeFilePromise(p: P, content: string | Buffer | ArrayBuffer | DataView, opts?: WriteFileOptions): void;
    writeFileSync(p: P, content: string | Buffer | ArrayBuffer | DataView, opts?: WriteFileOptions): void;
    unlinkPromise(p: P): Promise<void>;
    unlinkSync(p: P): void;
    utimesPromise(p: P, atime: Date | string | number, mtime: Date | string | number): Promise<void>;
    utimesSync(p: P, atime: Date | string | number, mtime: Date | string | number): void;
    mkdirPromise(p: P): Promise<void>;
    mkdirSync(p: P): void;
    rmdirPromise(p: P): Promise<void>;
    rmdirSync(p: P): void;
    symlinkPromise(target: P, p: P): Promise<void>;
    symlinkSync(target: P, p: P): void;
    readFilePromise(p: P, encoding: 'utf8'): Promise<string>;
    readFilePromise(p: P, encoding?: string): Promise<Buffer>;
    readFileSync(p: P, encoding: 'utf8'): string;
    readFileSync(p: P, encoding?: string): Buffer;
    readdirPromise(p: P): Promise<import("./path").Filename[]>;
    readdirSync(p: P): import("./path").Filename[];
    readlinkPromise(p: P): Promise<P>;
    readlinkSync(p: P): P;
}
