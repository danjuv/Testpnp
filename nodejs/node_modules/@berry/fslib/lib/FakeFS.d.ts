/// <reference types="node" />
import { ReadStream, Stats, WriteStream } from 'fs';
import { Path, PortablePath, PathUtils, Filename } from './path';
export declare type CreateReadStreamOptions = Partial<{
    encoding: string;
    fd: number;
}>;
export declare type CreateWriteStreamOptions = Partial<{
    encoding: string;
    fd: number;
    flags: 'a';
}>;
export declare type WriteFileOptions = Partial<{
    encoding: string;
    mode: number;
    flag: string;
}> | string;
export declare abstract class FakeFS<P extends Path> {
    readonly pathUtils: PathUtils<P>;
    protected constructor(pathUtils: PathUtils<P>);
    abstract getRealPath(): P;
    abstract resolve(p: P): P;
    abstract openPromise(p: P, flags: string, mode?: number): Promise<number>;
    abstract openSync(p: P, flags: string, mode?: number): number;
    abstract closePromise(fd: number): void;
    abstract closeSync(fd: number): void;
    abstract createWriteStream(p: P | null, opts?: CreateWriteStreamOptions): WriteStream;
    abstract createReadStream(p: P | null, opts?: CreateReadStreamOptions): ReadStream;
    abstract realpathPromise(p: P): Promise<P>;
    abstract realpathSync(p: P): P;
    abstract readdirPromise(p: P): Promise<Array<Filename>>;
    abstract readdirSync(p: P): Array<Filename>;
    abstract existsPromise(p: P): Promise<boolean>;
    abstract existsSync(p: P): boolean;
    abstract accessPromise(p: P, mode?: number): Promise<void>;
    abstract accessSync(p: P, mode?: number): void;
    abstract statPromise(p: P): Promise<Stats>;
    abstract statSync(p: P): Stats;
    abstract lstatPromise(p: P): Promise<Stats>;
    abstract lstatSync(p: P): Stats;
    abstract chmodPromise(p: P, mask: number): Promise<void>;
    abstract chmodSync(p: P, mask: number): void;
    abstract mkdirPromise(p: P): Promise<void>;
    abstract mkdirSync(p: P): void;
    abstract rmdirPromise(p: P): Promise<void>;
    abstract rmdirSync(p: P): void;
    abstract symlinkPromise(target: P, p: P): Promise<void>;
    abstract symlinkSync(target: P, p: P): void;
    abstract renamePromise(oldP: P, newP: P): Promise<void>;
    abstract renameSync(oldP: P, newP: P): void;
    abstract copyFilePromise(sourceP: P, destP: P, flags?: number): Promise<void>;
    abstract copyFileSync(sourceP: P, destP: P, flags?: number): void;
    abstract writeFilePromise(p: P, content: string | Buffer | ArrayBuffer | DataView, opts?: WriteFileOptions): void;
    abstract writeFileSync(p: P, content: string | Buffer | ArrayBuffer | DataView, opts?: WriteFileOptions): void;
    abstract unlinkPromise(p: P): Promise<void>;
    abstract unlinkSync(p: P): void;
    abstract utimesPromise(p: P, atime: Date | string | number, mtime: Date | string | number): Promise<void>;
    abstract utimesSync(p: P, atime: Date | string | number, mtime: Date | string | number): void;
    abstract readFilePromise(p: P, encoding: 'utf8'): Promise<string>;
    abstract readFilePromise(p: P, encoding?: string): Promise<Buffer>;
    abstract readFileSync(p: P, encoding: 'utf8'): string;
    abstract readFileSync(p: P, encoding?: string): Buffer;
    abstract readlinkPromise(p: P): Promise<P>;
    abstract readlinkSync(p: P): P;
    removePromise(p: P): Promise<void>;
    removeSync(p: P): void;
    mkdirpPromise(p: P, { chmod, utimes }?: {
        chmod?: number;
        utimes?: [Date | string | number, Date | string | number];
    }): Promise<void>;
    mkdirpSync(p: P, { chmod, utimes }?: {
        chmod?: number;
        utimes?: [Date | string | number, Date | string | number];
    }): void;
    copyPromise(destination: P, source: P, options?: {
        baseFs?: undefined;
        overwrite?: boolean;
    }): Promise<void>;
    copyPromise<P2 extends Path>(destination: P, source: P2, options: {
        baseFs: FakeFS<P2>;
        overwrite?: boolean;
    }): Promise<void>;
    copySync(destination: P, source: P, options?: {
        baseFs?: undefined;
        overwrite?: boolean;
    }): void;
    copySync<P2 extends Path>(destination: P, source: P2, options: {
        baseFs: FakeFS<P2>;
        overwrite?: boolean;
    }): void;
    changeFilePromise(p: P, content: string): Promise<void>;
    changeFileSync(p: P, content: string): void;
    movePromise(fromP: P, toP: P): Promise<void>;
    moveSync(fromP: P, toP: P): void;
    lockPromise<T>(affectedPath: P, callback: () => Promise<T>): Promise<T>;
}
export declare abstract class BasePortableFakeFS extends FakeFS<PortablePath> {
    protected constructor();
    resolve(p: PortablePath): PortablePath;
}
