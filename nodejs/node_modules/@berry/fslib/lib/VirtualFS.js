"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NodeFS_1 = require("./NodeFS");
const ProxiedFS_1 = require("./ProxiedFS");
const path_1 = require("./path");
// https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js
const escapeRegexp = (s) => s.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
class VirtualFS extends ProxiedFS_1.ProxiedFS {
    static makeVirtualPath(base, component, to) {
        // Obtains the relative distance between the virtual path and its actual target
        const target = path_1.ppath.relative(path_1.ppath.dirname(base), to);
        const segments = target.split(`/`);
        // Counts how many levels we need to go back to start applying the rest of the path
        let depth = 0;
        while (depth < segments.length && segments[depth] === `..`)
            depth += 1;
        const finalSegments = segments.slice(depth);
        const fullVirtualPath = path_1.ppath.join(base, component, String(depth), ...finalSegments);
        return fullVirtualPath;
    }
    constructor(virtual, { baseFs = new NodeFS_1.NodeFS() } = {}) {
        super(path_1.ppath);
        this.baseFs = baseFs;
        this.target = path_1.ppath.dirname(virtual);
        this.virtual = virtual;
        this.mapToBaseRegExp = new RegExp(`^(${escapeRegexp(this.virtual)})((?:/([^\/]+)(?:/([^/]+))?)?((?:/.*)?))$`);
    }
    getRealPath() {
        return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
    }
    realpathSync(p) {
        const match = p.match(this.mapToBaseRegExp);
        if (!match)
            return this.baseFs.realpathSync(p);
        if (!match[5])
            return p;
        const realpath = this.baseFs.realpathSync(this.mapToBase(p));
        return VirtualFS.makeVirtualPath(this.virtual, match[3], realpath);
    }
    async realpathPromise(p) {
        const match = p.match(this.mapToBaseRegExp);
        if (!match)
            return await this.baseFs.realpathPromise(p);
        if (!match[5])
            return p;
        const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
        return VirtualFS.makeVirtualPath(this.virtual, match[3], realpath);
    }
    mapToBase(p) {
        const match = p.match(this.mapToBaseRegExp);
        if (!match)
            return p;
        if (match[3])
            return path_1.ppath.join(this.target, `../`.repeat(Number(match[4])), match[5]);
        return this.target;
    }
    mapFromBase(p) {
        return p;
    }
}
exports.VirtualFS = VirtualFS;
